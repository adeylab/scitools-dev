#!/usr/bin/perl

# INITIALIZE LOCATION
BEGIN {
	use FindBin '$RealBin';
	push @INC, $RealBin;
}

# VERSION INFO
$version = "0.1.2";
%version_info = (
	"0.1.0" => "180215, alpha - initial development",
	"0.1.1d" => "180418, alpha - dev split",
	"0.1.2" => "180608, modulization"
);

# LOAD MODULES
use Getopt::Std; %opt = ();
use commands::general;
use Exporter "import";

# LOAD DEFAULTS
$SCITOOLS_DEFAULTS = "$RealBin/scitools.cfg";
if (-e "$ENV{'HOME'}/.scitools.cfg") {
	$SCITOOLS_DEFAULTS = "$ENV{'HOME'}/.scitools.cfg";
} elsif (-e "$ENV{'HOME'}/scitools.cfg") {
	$SCITOOLS_DEFAULTS = "$ENV{'HOME'}/scitools.cfg";
} elsif ($ARGV[0] =~ /\.cfg$/) {
	# special config specification as first argument - advanced use only
	$SCITOOLS_DEFAULTS = shift(@ARGV);
	print STDERR "INFO: Special config file detected as first argument. ($ARGV[0])\n";
}
load_defaults($SCITOOLS_DEFAULTS);
load_gradient_defaults();

# LOAD COMMANDS DIRECTLY FROM MODULE FILES
opendir CMDS, "$RealBin/commands" || die "ERROR: Cannot locate the commands directory.\nERROR: It should be present in the same directory as the scitools executable: $RealBin\n";
while ($command_module_name = readdir(CMDS)) {
	if ($command_module_name !~ /(^\.|general|empty_module|test|object)/ && $command_module_name =~ /\.pm$/) { # exceptions -> do not show as available commands
		$command_module_name =~ s/\.pm$//;
		$COMMAND_NAMES{$command_module_name} = 1;
	}
} closedir CMDS;

# LOAD ALIASES (optional for each command)
load_aliases();

# DIE MESSAGE
$die = "
scitools [command] [options] [arguments]

Version: $version ($version_info{$version})
    adeylab.org & github.com/adeylab

scitools is a set of commands for general processing of single-
cell combinatorial indexing data. It is predominantly a wrapper
for generating R or other scripts that will be stored and executed.

scitools commands are typically in the form of [class]-[operation].

run 'scitools list' to print out a list of commands and descriptions.
To list a subset of commands include an additional argument with the
search term, e.g. 'scitools list fastq'\n\n";

# PULL COMMAND
if (defined $ARGV[0]) {
	if ($ARGV[0] =~ /list/) {
		load_descriptions();
		$die .= "   Command:             Description:\n\n";
		foreach $command_module_name (sort {$a cmp $b} keys %COMMAND_NAMES) {
			if (!defined $ARGV[1] || $command_module_name =~ /$ARGV[1]/) {
				$list_command = sprintf("%-20s", $command_module_name);
				$list_command =~ s/_/-/g;
				if (defined $COMMAND_DESCRIPTOR{$command_module_name}) {
					$die .= "   $list_command $COMMAND_DESCRIPTOR{$command_module_name}\n";
				} else {
					$die .= "   $list_command WARNING: No description listed.\n";
				}
			}
		}
		die "$die\n";
	} else {
		$called_command = lc(shift(@ARGV));
		$called_command =~ s/-/_/g;
		if (defined $COMMAND_ALIAS{$called_command}) {
			$command = $COMMAND_ALIAS{$called_command};
		} else {$command = $called_command};
#		if (defined $COMMAND_CALL->{$command}) {
		if (defined $COMMAND_NAMES{$command}) {
			require "commands/$command.pm";
			import "commands::$command", "$command";
			\&$command(@ARGV);
		} else {
			$command =~ s/_/-/g;
			die "ERROR: There is no command '$command', verify the command call name.\n$die";
		}
	}
} else {
	die $die;
}

# SUBROUTINES
sub load_aliases {

	# FOR PULIC RELEASE
	
	foreach $alias ("dependencies", "depend") {$COMMAND_ALIAS{$alias} = "dependencies"};
	foreach $alias ("fastq_dump", "dump_fastq") {$COMMAND_ALIAS{$alias} = "fastq_dump"};
	foreach $alias ("fastq_split", "split_fastq") {$COMMAND_ALIAS{$alias} = "fastq_split"};
	foreach $alias ("fastq_merge", "merge_fastq") {$COMMAND_ALIAS{$alias} = "fastq_merge"};
	foreach $alias ("fastq_align", "align_fastq", "align") {$COMMAND_ALIAS{$alias} = "fastq_align"};
	foreach $alias ("bam_bulk2sci", "bulk2sci") {$COMMAND_ALIAS{$alias} = "bam_bulk2sci"};
	foreach $alias ("bam_addrg", "addrg") {$COMMAND_ALIAS{$alias} = "bam_addrg"};
	foreach $alias ("bam_rmdup", "rmdup") {$COMMAND_ALIAS{$alias} = "bam_rmdup"};
	foreach $alias ("bam_split", "split_bam") {$COMMAND_ALIAS{$alias} = "bam_split"};
	foreach $alias ("bam_filter", "filter_bam") {$COMMAND_ALIAS{$alias} = "bam_filter"};
	foreach $alias ("bam_merge", "merge_bam") {$COMMAND_ALIAS{$alias} = "bam_merge"};
	foreach $alias ("bam_project", "project_bam", "project") {$COMMAND_ALIAS{$alias} = "bam_project"};
	foreach $alias ("bam_aggregate", "aggregate_bam") {$COMMAND_ALIAS{$alias} = "bam_aggregate"};
	foreach $alias ("signal_make", "make_signal") {$COMMAND_ALIAS{$alias} = "signal_make"};
	foreach $alias ("plot_signal", "signal_plot") {$COMMAND_ALIAS{$alias} = "plot_signal"};
	foreach $alias ("annot_make", "make_annot") {$COMMAND_ALIAS{$alias} = "annot_make"};
	foreach $alias ("annot_merge", "merge_annot") {$COMMAND_ALIAS{$alias} = "annot_merge"};
	foreach $alias ("rename_cells") {$COMMAND_ALIAS{$alias} = "rename_cells"};
	foreach $alias ("atac_callpeaks", "atac_callpeak", "callpeak", "callpeaks") {$COMMAND_ALIAS{$alias} = "atac_callpeak"};
	foreach $alias ("atac_mergepeaks", "atac_mergepeak", "mergepeak", "mergepeaks") {$COMMAND_ALIAS{$alias} = "atac_mergepeak"};
	foreach $alias ("atac_counts", "atac_count", "count", "counts") {$COMMAND_ALIAS{$alias} = "atac_count"};
	foreach $alias ("matrix_filter", "filter_matrix") {$COMMAND_ALIAS{$alias} = "matrix_filter"};
	foreach $alias ("matrix_naomit", "naomit_matrix") {$COMMAND_ALIAS{$alias} = "matrix_naomit"};
	foreach $alias ("matrix_summarize", "summarize_matrix") {$COMMAND_ALIAS{$alias} = "matrix_summarize"};
	foreach $alias ("matrix_tf", "tf") {$COMMAND_ALIAS{$alias} = "matrix_tf"};
	foreach $alias ("matrix_tfidf", "tfidf") {$COMMAND_ALIAS{$alias} = "matrix_tfidf"};
	foreach $alias ("matrix_lsi", "lsi") {$COMMAND_ALIAS{$alias} = "matrix_lsi"};
	foreach $alias ("matrix_zscore", "zscore_matrix") {$COMMAND_ALIAS{$alias} = "matrix_zscore"};
	foreach $alias ("matrix_tsne", "tsne") {$COMMAND_ALIAS{$alias} = "matrix_tsne"};
	foreach $alias ("matrix_pca", "pca") {$COMMAND_ALIAS{$alias} = "matrix_pca"};
	foreach $alias ("matrix_aggregate", "aggregate_matrix") {$COMMAND_ALIAS{$alias} = "matrix_aggregate"};
	foreach $alias ("matrix_merge", "merge_matrix") {$COMMAND_ALIAS{$alias} = "matrix_merge"};
	foreach $alias ("dims_kmeans", "kmeans") {$COMMAND_ALIAS{$alias} = "dims_kmeans"};
	foreach $alias ("dims_dbscan", "dbscan") {$COMMAND_ALIAS{$alias} = "dims_dbscan"};
	foreach $alias ("dims_pcurve", "pcurve") {$COMMAND_ALIAS{$alias} = "dims_pcurve"};
	foreach $alias ("pcurve_center", "center_pcurve", "lambda_center", "center_lambda") {$COMMAND_ALIAS{$alias} = "pcurve_center"};
	foreach $alias ("prune_pcurve", "pcurve_prune") {$COMMAND_ALIAS{$alias} = "pcurve_prune"};
	foreach $alias ("aggregate_cells", "aggregate") {$COMMAND_ALIAS{$alias} = "aggregate_cells"};
	foreach $alias ("plot_complexity") {$COMMAND_ALIAS{$alias} = "plot_complexity"};
	foreach $alias ("plot_dims") {$COMMAND_ALIAS{$alias} = "plot_dims"};
	foreach $alias ("plot_pcurve") {$COMMAND_ALIAS{$alias} = "plot_pcurve"};
	foreach $alias ("plot_reads") {$COMMAND_ALIAS{$alias} = "plot_reads"};
	foreach $alias ("index_performance", "index_perform") {$COMMAND_ALIAS{$alias} = "index_performance"};
	foreach $alias ("combine_data", "data_combine") {$COMMAND_ALIAS{$alias} = "data_combine"};
	foreach $alias ("split_data", "data_split") {$COMMAND_ALIAS{$alias} = "data_split"};
	
	# INTERNAL / DEVELOPMENT COMMANDS

	foreach $alias ("atac_chromvar", "chromvar") {$COMMAND_ALIAS{$alias} = "atac_chromvar"};
	foreach $alias ("matrix_approx_factors", "matrix_factors", "factors") {$COMMAND_ALIAS{$alias} = "matrix_factors"};
	foreach $alias ("matrix_swne", "swne", "piglet") {$COMMAND_ALIAS{$alias} = "matrix_swne"};
	foreach $alias ("umap", "owl", "matrix_umap") {$COMMAND_ALIAS{$alias} = "matrix_umap"};
	foreach $alias ("plot_factors") {$COMMAND_ALIAS{$alias} = "plot_factors"};

}

sub load_descriptions {

	# FOR PULIC RELEASE
	
	$COMMAND_DESCRIPTOR{"dependencies"} = "Check dependencies";
	$COMMAND_DESCRIPTOR{"gradient"} = "Print out color gradient pre-sets and details";
	$COMMAND_DESCRIPTOR{"fastq_dump"} = "Go from illumina fastqs to SCI fastq format";
	$COMMAND_DESCRIPTOR{"fastq_split"} = "Split SCI fastq files using annotation file";
	$COMMAND_DESCRIPTOR{"fastq_merge"} = "Merge fastq files that have the same barcodes";
	$COMMAND_DESCRIPTOR{"fastq_align"} = "Align fastq files and sort resulting bam file";
	$COMMAND_DESCRIPTOR{"bam_bulk2sci"} = "Merge multiple bulk bam files to one SCI bam";
	$COMMAND_DESCRIPTOR{"bam_addrg"} = "Add RG lines to bam";
	$COMMAND_DESCRIPTOR{"bam_rmdup"} = "Barcode-based duplicate removal";
	$COMMAND_DESCRIPTOR{"bam_filter"} = "Filter bam based on a variety of options";
	$COMMAND_DESCRIPTOR{"bam_split"} = "Split bam by annotation file";
	$COMMAND_DESCRIPTOR{"bam_merge"} = "Merges one or more bam files";
	$COMMAND_DESCRIPTOR{"bam_project"} = "Use complexity to project additional sequence";
	$COMMAND_DESCRIPTOR{"bam_aggregate"} = "Aggregate cells in bam by annotation file";
	$COMMAND_DESCRIPTOR{"annot_make"} = "Make annotation file";
	$COMMAND_DESCRIPTOR{"annot_merge"} = "Merge annotation files";
	$COMMAND_DESCRIPTOR{"rename_cells"} = "Rename cells";
	$COMMAND_DESCRIPTOR{"atac_callpeak"} = "Call peaks on bam file using macs2";
	$COMMAND_DESCRIPTOR{"atac_mergepeak"} = "Merge ATAC_seq peak files";
	$COMMAND_DESCRIPTOR{"atac_count"} = "Bam and peak file to a counts matrix";
	$COMMAND_DESCRIPTOR{"signal_make"} = "Generate windowed signal over features from bam";
	$COMMAND_DESCRIPTOR{"plot_signal"} = "Plot windowed signal views";
	$COMMAND_DESCRIPTOR{"matrix_summarize"} = "Generate a summary and plots on matrix properties";
	$COMMAND_DESCRIPTOR{"matrix_filter"} = "Filter a sci-ATAC-seq counts matrix";
	$COMMAND_DESCRIPTOR{"matrix_naomit"} = "Filter out rows with NA values";
	$COMMAND_DESCRIPTOR{"matrix_zscore"} = "Z-scores matrix by rows, columns, or globally";
	$COMMAND_DESCRIPTOR{"matrix_tf"} = "Normalize only by term frequency";
	$COMMAND_DESCRIPTOR{"matrix_tfidf"} = "Perform tf-idf on counts matrix";
	$COMMAND_DESCRIPTOR{"matrix_lsi"} = "Perform Latent Semantic Indexing on matrix";
	$COMMAND_DESCRIPTOR{"matrix_tsne"} = "tSNE on matrix";
	$COMMAND_DESCRIPTOR{"matrix_pca"} = "PCA on matrix";
	$COMMAND_DESCRIPTOR{"matrix_aggregate"} = "Aggregate cells in counts matrix by annotation";
	$COMMAND_DESCRIPTOR{"matrix_merge"} = "Merge matrices, no overlap in cell names assumed";
	$COMMAND_DESCRIPTOR{"dims_kmeans"} = "Kmeans clustering on dims file";
	$COMMAND_DESCRIPTOR{"dims_dbscan"} = "Density-base (dbscan) clustering on dims file";
	$COMMAND_DESCRIPTOR{"dims_pcurve"} = "Project a principle curve through dims file";
	$COMMAND_DESCRIPTOR{"pcurve_center"} = "Centers and normalizes a pcurve lambda";
	$COMMAND_DESCRIPTOR{"pcurve_prune"} = "Prunes cells distant from the pcurve";
	$COMMAND_DESCRIPTOR{"aggregate_cells"} = "Aggregate cells in proximity with one another";
	$COMMAND_DESCRIPTOR{"plot_complexity"} = "Plot complexity data";
	$COMMAND_DESCRIPTOR{"plot_dims"} = "Plot tSNE or other dimensions file";
	$COMMAND_DESCRIPTOR{"plot_pcurve"} = "Genrate multiple princurve plots";
	$COMMAND_DESCRIPTOR{"plot_reads"} = "Plot reads as points in genomic window";
	$COMMAND_DESCRIPTOR{"index_performance"} = "Index performance on fastq or bam";
	$COMMAND_DESCRIPTOR{"data_combine"} = "Combine matrixes, annotations, dims to a table";
	$COMMAND_DESCRIPTOR{"data_split"} = "Breaks a combined data file into component files";
	
	# INTERNAL / DEVELOPMENT COMMANDS
	
	$COMMAND_DESCRIPTOR{"check_vars"} = "Debugging tool to test vars passed to a command";
	$COMMAND_DESCRIPTOR{"atac_chromvar"} = "Run chromVAR wrapper on sci-ATAC-seq data";
	$COMMAND_DESCRIPTOR{"matrix_factors"} = "Calculates reconstruction error for NMF and SWNE";
	$COMMAND_DESCRIPTOR{"matrix_nmf"} = "Non-negative Matrix Factorization of matrix";
	$COMMAND_DESCRIPTOR{"matrix_swne"} = "SWNE on matrix ";
	$COMMAND_DESCRIPTOR{"matrix_umap"} = "UMAP on matrix";
	$COMMAND_DESCRIPTOR{"plot_factors"} = "Generates factor vs reconstruction error plot";
	
	$COMMAND_DESCRIPTOR{"matrix_bicluster"} = "Bicluster and plot a heatmap";
	
}
